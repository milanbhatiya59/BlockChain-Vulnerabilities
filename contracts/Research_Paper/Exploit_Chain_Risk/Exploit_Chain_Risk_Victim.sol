// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/*
 Exploit_Chain_Risk_Victim.sol
 Purpose: Demonstrates exploit chain vulnerabilities where multiple contract weaknesses
 combine to create a critical security risk.
 
 Vulnerability Pattern:
 - GovernanceToken has weak owner controls (transferOwner with no timelock/multisig)
 - ProtocolVault trusts the governor address implicitly
 - When combined: attacker can gain governance token ownership -> become vault governor -> drain funds
 
 This demonstrates how weaknesses in separate modules (token governance + protocol config)
 can chain into an overall vulnerability even if each contract superficially "works".
*/

// Simple governance token with mint-by-owner (owner can be handed out carelessly)
contract GovToken {
    mapping(address => uint256) public balanceOf;
    address public owner;
    
    event OwnerTransferred(address indexed previousOwner, address indexed newOwner);
    event TokensMinted(address indexed to, uint256 amount);

    constructor() { 
        owner = msg.sender;
        emit OwnerTransferred(address(0), msg.sender);
    }

    // ❌ VULNERABILITY 1: owner-only mint with no governance checks
    // Owner rights might be transferred by poor practices elsewhere
    function mint(address to, uint256 amount) external {
        require(msg.sender == owner, "only owner");
        balanceOf[to] += amount;
        emit TokensMinted(to, amount);
    }

    // ❌ VULNERABILITY 2: naive transferOwner (no governance process, no timelock)
    function transferOwner(address newOwner) external {
        require(msg.sender == owner, "only owner");
        address previousOwner = owner;
        owner = newOwner;
        emit OwnerTransferred(previousOwner, newOwner);
    }
    
    function transfer(address to, uint256 amount) external {
        require(balanceOf[msg.sender] >= amount, "insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
    }
}

// Protocol config that trusts governance decisions from GovToken.owner
contract ProtocolVault {
    address public governor; // expected to be controlled by a multisig/governance in safe designs
    mapping(address => uint256) public vaultBalances;
    
    event GovernorChanged(address indexed previousGovernor, address indexed newGovernor);
    event EmergencyWithdrawal(address indexed to, uint256 amount);
    event Deposit(address indexed from, uint256 amount);

    constructor(address _governor) {
        governor = _governor;
        emit GovernorChanged(address(0), _governor);
    }

    // ❌ VULNERABILITY 3: naive admin change callable by governor address
    // Assumes governor is secure, but if GovToken owner is compromised, so is this
    function setGovernor(address newGov) external {
        require(msg.sender == governor, "only governor");
        address previousGovernor = governor;
        governor = newGov;
        emit GovernorChanged(previousGovernor, newGov);
    }

    // ❌ VULNERABILITY 4: admin-only emergencyWithdraw (assumes governor is honest)
    function emergencyWithdraw(address to, uint256 amount) external {
        require(msg.sender == governor, "only governor");
        require(address(this).balance >= amount, "insufficient balance");
        
        // transfer funds
        (bool ok, ) = payable(to).call{value: amount}("");
        require(ok, "send failed");
        
        emit EmergencyWithdrawal(to, amount);
    }

    // accept deposits to the vault
    function deposit() external payable {
        vaultBalances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    receive() external payable {
        vaultBalances[msg.sender] += msg.value;
        emit Deposit(msg.sender, msg.value);
    }
    
    function getBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

// ❌ VULNERABILITY 5: Coupling without security boundaries
// This contract demonstrates the exploit chain by combining both contracts
contract ExploitChainSystem {
    GovToken public govToken;
    ProtocolVault public vault;
    
    event SystemDeployed(address govToken, address vault);
    
    constructor(address _govToken, address payable _vault) payable {
        govToken = GovToken(_govToken);
        vault = ProtocolVault(_vault);
        
        // Fund the vault with initial capital if provided
        if (msg.value > 0) {
            (bool success, ) = _vault.call{value: msg.value}("");
            require(success, "funding failed");
        }
        
        emit SystemDeployed(address(govToken), address(vault));
    }
    
    // ❌ VULNERABILITY 6: System allows governor to transfer ownership carelessly
    function delegateGovernance(address newGovernor) external {
        require(msg.sender == govToken.owner() || msg.sender == vault.governor(), "not authorized");
        vault.setGovernor(newGovernor);
    }
    
    // ❌ VULNERABILITY 7: System allows token ownership transfer without checks
    function delegateTokenOwnership(address newOwner) external {
        require(msg.sender == govToken.owner(), "not token owner");
        govToken.transferOwner(newOwner);
    }
    
    function fundVault() external payable {
        payable(address(vault)).transfer(msg.value);
    }
}

// Vulnerable integration: Protocol that accepts governance changes without validation
contract VulnerableProtocol {
    GovToken public govToken;
    ProtocolVault public vault;
    address public admin;
    
    mapping(address => bool) public trustedGovernors;
    
    event GovernanceAccepted(address indexed governor);
    event ProtocolCompromised(address indexed attacker, uint256 amount);
    
    constructor(address _govToken, address payable _vault) {
        govToken = GovToken(_govToken);
        vault = ProtocolVault(_vault);
        admin = msg.sender;
    }
    
    // ❌ VULNERABILITY 8: Accepts any address as governor without verification
    function acceptGovernor(address governor_) external {
        require(msg.sender == admin, "only admin");
        trustedGovernors[governor_] = true;
        emit GovernanceAccepted(governor_);
    }
    
    // ❌ VULNERABILITY 9: Allows governance changes based on token ownership
    // If token ownership is compromised, entire protocol is at risk
    function syncGovernance() external {
        address currentOwner = govToken.owner();
        trustedGovernors[currentOwner] = true;
        vault.setGovernor(currentOwner);
        emit GovernanceAccepted(currentOwner);
    }
    
    function depositToVault() external payable {
        vault.deposit{value: msg.value}();
    }
}
