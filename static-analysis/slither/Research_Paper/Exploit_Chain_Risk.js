const { exec } = require('child_process');
const path = require('path');
const fs = require('fs');

console.log('\n=== Research Paper: Exploit Chain Risk - Slither Static Analysis ===\n');

const contractPath = path.join(__dirname, '../../../contracts/Research_Paper/Exploit_Chain_Risk/Exploit_Chain_Risk_Victim.sol');

console.log('ğŸ“‹ Running Slither analysis on ExploitChainRiskVictim contract...\n');
console.log(`Contract: ${contractPath}\n`);

const slitherCommand = `slither ${contractPath} --detect reentrancy-eth,unprotected-upgrade,arbitrary-send-eth --json -`;

exec(slitherCommand, { maxBuffer: 1024 * 1024 * 10 }, (error, stdout, stderr) => {
  
  let analysis = { critical: [], high: [], medium: [], low: [], informational: [] };

  if (stdout) {
    try {
      const results = JSON.parse(stdout);
      if (results.success && results.results && results.results.detectors) {
        results.results.detectors.forEach(issue => {
          const severity = issue.impact.toLowerCase();
          if (analysis[severity]) {
            analysis[severity].push({
              check: issue.check,
              impact: issue.impact,
              confidence: issue.confidence,
              description: issue.description
            });
          }
        });
      }

      console.log('ğŸ” Slither Analysis Results:\n');
      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

      ['critical', 'high', 'medium', 'low', 'informational'].forEach(severity => {
        const issues = analysis[severity];
        if (issues.length > 0) {
          console.log(`${getIcon(severity)} ${severity.toUpperCase()} Severity Issues: ${issues.length}\n`);
          issues.forEach((issue, idx) => {
            console.log(`  ${idx + 1}. [${issue.check}] - Confidence: ${issue.confidence}`);
            console.log(`     ${issue.description}\n`);
          });
        }
      });

      console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
    } catch (parseError) {
      console.log('ğŸ“Š Slither Raw Output:\n' + stdout);
    }
  }

  if (stderr && !stderr.includes('Compilation warnings')) {
    console.log('âš ï¸  Slither Warnings:\n' + stderr + '\n');
  }

  console.log('ğŸ¯ Exploit Chain Risk Analysis:\n');
  console.log('ğŸ“– Concept: Multiple vulnerabilities that can be chained together');
  console.log('   to create a more severe exploit than any single vulnerability.\n');
  
  const contractCode = fs.readFileSync(contractPath, 'utf8');

  // Check for multiple vulnerability types
  const vulnPatterns = [
    { pattern: /\.call\{value:/g, name: 'Reentrancy vectors', severity: 'ğŸ”´' },
    { pattern: /onlyOwner|owner\s*=/g, name: 'Access control points', severity: 'ğŸŸ ' },
    { pattern: /block\.timestamp|block\.number/g, name: 'Timestamp dependency', severity: 'ğŸŸ¡' },
    { pattern: /delegatecall/g, name: 'Delegatecall usage', severity: 'ğŸ”´' },
    { pattern: /selfdestruct/g, name: 'Selfdestruct calls', severity: 'ğŸ”´' }
  ];

  console.log('Vulnerability Surface Analysis:\n');
  let totalVulnSurface = 0;

  vulnPatterns.forEach(vuln => {
    const matches = (contractCode.match(vuln.pattern) || []).length;
    if (matches > 0) {
      totalVulnSurface++;
      console.log(`  ${vuln.severity} ${vuln.name}: ${matches}`);
    }
  });

  console.log(`\n  Total vulnerability surfaces: ${totalVulnSurface}`);
  if (totalVulnSurface >= 3) {
    console.log(`  ğŸ”´ HIGH RISK: Multiple exploit vectors present!`);
    console.log(`     These can potentially be chained together.`);
  }

  console.log('\nâš ï¸  Exploit Chain Risk Pattern:\n');
  console.log('  Attack chains typically follow this pattern:');
  console.log('  1. Initial Entry: Exploit first vulnerability (e.g., access control)');
  console.log('  2. Privilege Escalation: Gain elevated permissions');
  console.log('  3. State Manipulation: Use permissions to alter contract state');
  console.log('  4. Value Extraction: Exploit modified state for profit');
  console.log('  5. Cover Tracks: Optionally hide evidence of attack\n');

  console.log('  Example Chain:');
  console.log('    Step 1: Exploit missing access control â†’ become owner');
  console.log('    Step 2: Use owner privileges â†’ modify critical parameters');
  console.log('    Step 3: Exploit reentrancy â†’ drain funds');
  console.log('    Step 4: selfdestruct â†’ remove evidence\n');

  console.log('ğŸ›¡ï¸  Mitigation Strategies:\n');
  console.log('  1. âœ… Defense in Depth:');
  console.log('     - Multiple layers of security');
  console.log('     - Don\'t rely on single protection mechanism\n');
  console.log('  2. âœ… Isolation:');
  console.log('     - Separate critical functions into different contracts');
  console.log('     - Limit cross-function dependencies\n');
  console.log('  3. âœ… Rate Limiting:');
  console.log('     - Prevent rapid exploitation of multiple vulnerabilities\n');
  console.log('  4. âœ… Circuit Breakers:');
  console.log('     - Pause functionality if anomalous behavior detected\n');
  console.log('  5. âœ… Comprehensive Testing:');
  console.log('     - Test combinations of actions, not just individual functions');

  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  
  if (error && !stdout) {
    console.error('âŒ Error running Slither. Install: pip3 install slither-analyzer\n');
    process.exit(1);
  }
  process.exit(0);
});

function getIcon(severity) {
  return { critical: 'ğŸ”´', high: 'ğŸŸ ', medium: 'ğŸŸ¡', low: 'ğŸ”µ', informational: 'â„¹ï¸' }[severity] || 'âšª';
}
