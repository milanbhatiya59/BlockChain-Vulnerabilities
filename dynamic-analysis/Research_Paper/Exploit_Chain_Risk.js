const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("Research Paper: Exploit Chain Risk - Dynamic Analysis", function () {
    let govToken;
    let vault;
    let system;
    let protocol;
    let attacker;
    let systemExploiter;
    let privilegeEscalationAttacker;
    let owner;
    let user1;
    let user2;
    let attacker1;
    
    beforeEach(async function () {
        [owner, user1, user2, attacker1] = await ethers.getSigners();
        
        // Deploy basic GovToken and ProtocolVault
        const GovToken = await ethers.getContractFactory("GovToken");
        govToken = await GovToken.deploy();
        await govToken.waitForDeployment();
        
        const govTokenAddress = await govToken.getAddress();
        const ProtocolVault = await ethers.getContractFactory("ProtocolVault");
        vault = await ProtocolVault.deploy(owner.address);  // Owner is initial governor
        await vault.waitForDeployment();
        
        // Fund the vault
        await vault.deposit({ value: ethers.parseEther("10.0") });
        
        const vaultAddress = await vault.getAddress();
        
        // Deploy a separate vault for the ExploitChainSystem
        const SystemVault = await ethers.getContractFactory("ProtocolVault");
        const systemVault = await SystemVault.deploy(owner.address);
        await systemVault.waitForDeployment();
        const systemVaultAddress = await systemVault.getAddress();
        
        // Deploy ExploitChainSystem with its own vault
        const ExploitChainSystem = await ethers.getContractFactory("ExploitChainSystem");
        system = await ExploitChainSystem.deploy(govTokenAddress, systemVaultAddress, { value: ethers.parseEther("20.0") });
        await system.waitForDeployment();
        
        // Set system as governor of its vault
        let systemAddress = await system.getAddress();
        await systemVault.setGovernor(systemAddress);
        
        // Deploy a separate vault for VulnerableProtocol
        const ProtocolVault2 = await ethers.getContractFactory("ProtocolVault");
        const protocolVault = await ProtocolVault2.deploy(owner.address);
        await protocolVault.waitForDeployment();
        const protocolVaultAddress = await protocolVault.getAddress();
        await protocolVault.deposit({ value: ethers.parseEther("10.0") });
        
        // Deploy VulnerableProtocol
        const VulnerableProtocol = await ethers.getContractFactory("VulnerableProtocol");
        protocol = await VulnerableProtocol.deploy(govTokenAddress, protocolVaultAddress);
        await protocol.waitForDeployment();
        
        // Set protocol as governor of its vault
        const protocolAddress = await protocol.getAddress();
        await protocolVault.setGovernor(protocolAddress);
        
        // Deploy attackers
        const ExploitChainAttacker = await ethers.getContractFactory("ExploitChainAttacker");
        attacker = await ExploitChainAttacker.connect(attacker1).deploy(govTokenAddress, await vault.getAddress());
        await attacker.waitForDeployment();
        
        systemAddress = await system.getAddress();
        const SystemExploiter = await ethers.getContractFactory("SystemExploiter");
        systemExploiter = await SystemExploiter.connect(attacker1).deploy(systemAddress);
        await systemExploiter.waitForDeployment();
        
        const PrivilegeEscalationAttacker = await ethers.getContractFactory("PrivilegeEscalationAttacker");
        privilegeEscalationAttacker = await PrivilegeEscalationAttacker.connect(attacker1).deploy();
        await privilegeEscalationAttacker.waitForDeployment();
    });
    
    describe("Vulnerability Detection", function () {
        it("Should detect weak ownership transfer in GovToken", async function () {
            const initialOwner = await govToken.owner();
            expect(initialOwner).to.equal(owner.address);
            
            // Owner can transfer to anyone without checks
            await govToken.transferOwner(user1.address);
            
            const newOwner = await govToken.owner();
            expect(newOwner).to.equal(user1.address);
            
            console.log("    ❌ Ownership transferred without timelock or governance");
            console.log("    Initial owner:", initialOwner);
            console.log("    New owner:", newOwner);
        });
        
        it("Should detect vault governor can drain funds", async function () {
            const vaultBalance = await vault.getBalance();
            expect(vaultBalance).to.equal(ethers.parseEther("10.0"));
            
            const governor = await vault.governor();
            console.log("    Vault balance:", ethers.formatEther(vaultBalance), "ETH");
            console.log("    Governor:", governor);
            console.log("    ❌ Governor has unrestricted emergencyWithdraw access");
            
            // Governor can drain entire vault
            const governorBalanceBefore = await ethers.provider.getBalance(owner.address);
            await vault.emergencyWithdraw(owner.address, vaultBalance);
            const governorBalanceAfter = await ethers.provider.getBalance(owner.address);
            
            expect(await vault.getBalance()).to.equal(0);
            expect(governorBalanceAfter).to.be.gt(governorBalanceBefore);
            
            console.log("    ✓ Vault drained successfully");
        });
        
        it("Should detect exploit chain: token ownership -> vault control", async function () {
            // Setup: Make attacker the token owner
            await govToken.transferOwner(await attacker.getAddress());
            
            const tokenOwner = await govToken.owner();
            console.log("    Step 1: Attacker gained token ownership");
            console.log("    Token owner:", tokenOwner);
            
            // Make attacker the vault governor
            await vault.setGovernor(await attacker.getAddress());
            
            const vaultGovernor = await vault.governor();
            console.log("    Step 2: Attacker became vault governor");
            console.log("    Vault governor:", vaultGovernor);
            
            const vaultBalanceBefore = await vault.getBalance();
            console.log("    Step 3: Vault balance before drain:", ethers.formatEther(vaultBalanceBefore), "ETH");
            
            // Execute drain
            await attacker.connect(attacker1).step3_DrainVault();
            
            const vaultBalanceAfter = await vault.getBalance();
            const attackerBalance = await ethers.provider.getBalance(await attacker.getAddress());
            
            console.log("    Step 4: Vault drained!");
            console.log("    Vault balance after:", ethers.formatEther(vaultBalanceAfter), "ETH");
            console.log("    Attacker balance:", ethers.formatEther(attackerBalance), "ETH");
            console.log("    ❌ Exploit chain successful!");
            
            expect(vaultBalanceAfter).to.equal(0);
            expect(attackerBalance).to.equal(vaultBalanceBefore);
        });
        
        it("Should detect system-wide vulnerability coupling", async function () {
            const systemGovToken = await system.govToken();
            const systemVault = await system.vault();
            
            const govTokenContract = await ethers.getContractAt("GovToken", systemGovToken);
            const vaultContract = await ethers.getContractAt("ProtocolVault", systemVault);
            
            const tokenOwner = await govTokenContract.owner();
            const vaultGovernor = await vaultContract.governor();
            const systemAddress = await system.getAddress();
            
            console.log("    System components:");
            console.log("    - GovToken:", systemGovToken);
            console.log("    - Vault:", systemVault);
            console.log("    - Token owner:", tokenOwner);
            console.log("    - Vault governor:", vaultGovernor);
            console.log("    - System address:", systemAddress);
            console.log("    ❌ Tight coupling without security boundaries");
            
            expect(vaultGovernor).to.equal(systemAddress);
        });
        
        it("Should detect protocol's blind trust in governance", async function () {
            const protocolGovToken = await protocol.govToken();
            const protocolVault = await protocol.vault();
            
            console.log("    Protocol trusts:");
            console.log("    - GovToken:", protocolGovToken);
            console.log("    - Vault:", protocolVault);
            
            // Protocol accepts any governor through syncGovernance
            const govTokenContract = await ethers.getContractAt("GovToken", protocolGovToken);
            await govTokenContract.transferOwner(attacker1.address);
            
            // Sync governance makes attacker trusted
            await protocol.connect(owner).syncGovernance();
            
            const isTrusted = await protocol.trustedGovernors(attacker1.address);
            
            console.log("    Attacker synced as governor:", isTrusted);
            console.log("    ❌ Protocol blindly trusts token owner");
            
            expect(isTrusted).to.be.true;
        });
    });
    
    describe("Attack Scenarios", function () {
        it("Should execute complete exploit chain attack", async function () {
            // Step 1: Attacker gains token ownership (simulated)
            await govToken.transferOwner(await attacker.getAddress());
            console.log("    [+] Step 1: Gained token ownership");
            
            // Step 2: Change vault governor to attacker
            await vault.setGovernor(await attacker.getAddress());
            console.log("    [+] Step 2: Became vault governor");
            
            const vaultBalanceBefore = await vault.getBalance();
            const attackerBalanceBefore = await ethers.provider.getBalance(await attacker.getAddress());
            
            console.log("    [+] Step 3: Vault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
            
            // Step 3: Execute full chain
            await attacker.connect(attacker1).executeFullChain();
            
            const vaultBalanceAfter = await vault.getBalance();
            const attackerBalanceAfter = await ethers.provider.getBalance(await attacker.getAddress());
            
            console.log("    [+] Step 4: Attack complete!");
            console.log("    Vault balance after:", ethers.formatEther(vaultBalanceAfter), "ETH");
            console.log("    Stolen:", ethers.formatEther(vaultBalanceBefore), "ETH");
            
            expect(vaultBalanceAfter).to.equal(0);
            expect(attackerBalanceAfter).to.equal(vaultBalanceBefore);
        });
        
        it("Should exploit system through governance delegation", async function () {
            const systemGovToken = await system.govToken();
            const systemVault = await system.vault();
            
            const govTokenContract = await ethers.getContractAt("GovToken", systemGovToken);
            const vaultContract = await ethers.getContractAt("ProtocolVault", systemVault);
            
            // Initial state
            const vaultBalanceBefore = await vaultContract.getBalance();
            console.log("    System vault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
            
            // Transfer token ownership to exploiter
            await govTokenContract.transferOwner(await systemExploiter.getAddress());
            console.log("    [+] Transferred token ownership to exploiter");
            
            // Exploiter exploits the governance chain
            await systemExploiter.connect(attacker1).exploitGovernanceChain();
            console.log("    [+] Exploiter delegated governance and drained vault");
            
            const vaultBalanceAfter = await vaultContract.getBalance();
            expect(vaultBalanceAfter).to.equal(0);
            
            console.log("    [+] Exploiter is now vault governor");
            console.log("    ❌ System compromised through delegation!");
        });
        
        it("Should demonstrate privilege escalation attack", async function () {
            // Setup: Give attacker token ownership
            await govToken.transferOwner(await privilegeEscalationAttacker.getAddress());
            await vault.setGovernor(await privilegeEscalationAttacker.getAddress());
            
            const govTokenAddress = await govToken.getAddress();
            const vaultAddress = await vault.getAddress();
            
            // Check escalation status
            const status = await privilegeEscalationAttacker.demonstrateChain(
                govTokenAddress,
                vaultAddress
            );
            
            console.log("    Escalation status:", status);
            expect(status).to.equal("Full control: Can drain vault");
            
            // Execute extraction
            const vaultBalanceBefore = await vault.getBalance();
            await privilegeEscalationAttacker.connect(attacker1).extractFunds(vaultAddress);
            const vaultBalanceAfter = await vault.getBalance();
            
            console.log("    Extracted:", ethers.formatEther(vaultBalanceBefore), "ETH");
            expect(vaultBalanceAfter).to.equal(0);
        });
        
        it("Should exploit protocol integration vulnerability", async function () {
            // Transfer token ownership to system exploiter
            await govToken.transferOwner(await systemExploiter.getAddress());
            
            const protocolAddress = await protocol.getAddress();
            const protocolVaultAddress = await protocol.vault();
            const protocolVault = await ethers.getContractAt("ProtocolVault", protocolVaultAddress);
            const vaultBalanceBefore = await protocolVault.getBalance();
            
            console.log("    Protocol vault balance:", ethers.formatEther(vaultBalanceBefore), "ETH");
            
            // Exploit protocol integration
            await systemExploiter.connect(attacker1).exploitProtocolIntegration(protocolAddress);
            
            const vaultBalanceAfter = await protocolVault.getBalance();
            const exploiterBalance = await ethers.provider.getBalance(await systemExploiter.getAddress());
            
            console.log("    [+] Protocol integration exploited");
            console.log("    Vault drained:", ethers.formatEther(vaultBalanceBefore), "ETH");
            console.log("    Exploiter gained:", ethers.formatEther(exploiterBalance), "ETH");
            
            expect(vaultBalanceAfter).to.equal(0);
        });
    });
    
    describe("Exploit Chain Analysis", function () {
        it("Should analyze multi-hop attack path", async function () {
            console.log("\n    === Exploit Chain Analysis ===");
            console.log("    Chain: Token Ownership -> Vault Governor -> Fund Drain");
            console.log("");
            
            // Hop 1: Token ownership
            console.log("    Hop 1: Gain Token Ownership");
            console.log("      - Weakness: transferOwner() has no timelock");
            console.log("      - Weakness: No multi-sig requirement");
            console.log("      - Weakness: No governance vote needed");
            
            // Hop 2: Vault control
            console.log("\n    Hop 2: Control Vault through Governance");
            console.log("      - Weakness: Vault trusts governor implicitly");
            console.log("      - Weakness: setGovernor() can be called by anyone who is governor");
            console.log("      - Weakness: No verification of governor legitimacy");
            
            // Hop 3: Fund extraction
            console.log("\n    Hop 3: Extract Funds");
            console.log("      - Weakness: emergencyWithdraw() has no limits");
            console.log("      - Weakness: No timelock on withdrawal");
            console.log("      - Weakness: No community oversight");
            
            console.log("\n    ❌ Impact: Complete protocol takeover from single weak point");
        });
        
        it("Should demonstrate cascading failure", async function () {
            // Deploy multiple vaults that trust same governance
            const ProtocolVault = await ethers.getContractFactory("ProtocolVault");
            const vault2 = await ProtocolVault.deploy(owner.address);
            await vault2.waitForDeployment();
            await vault2.deposit({ value: ethers.parseEther("5.0") });
            
            const vault3 = await ProtocolVault.deploy(owner.address);
            await vault3.waitForDeployment();
            await vault3.deposit({ value: ethers.parseEther("3.0") });
            
            console.log("    Deployed 3 vaults with same governance");
            console.log("    Vault 1:", ethers.formatEther(await vault.getBalance()), "ETH");
            console.log("    Vault 2:", ethers.formatEther(await vault2.getBalance()), "ETH");
            console.log("    Vault 3:", ethers.formatEther(await vault3.getBalance()), "ETH");
            
            // Compromise token
            await govToken.transferOwner(attacker1.address);
            
            // Change all vault governors
            await vault.setGovernor(attacker1.address);
            await vault2.setGovernor(attacker1.address);
            await vault3.setGovernor(attacker1.address);
            
            // Drain all vaults
            await vault.connect(attacker1).emergencyWithdraw(attacker1.address, await vault.getBalance());
            await vault2.connect(attacker1).emergencyWithdraw(attacker1.address, await vault2.getBalance());
            await vault3.connect(attacker1).emergencyWithdraw(attacker1.address, await vault3.getBalance());
            
            console.log("    [+] All vaults drained through single compromise");
            console.log("    ❌ Cascading failure: 1 weakness -> 3 vaults lost");
            
            expect(await vault.getBalance()).to.equal(0);
            expect(await vault2.getBalance()).to.equal(0);
            expect(await vault3.getBalance()).to.equal(0);
        });
    });
    
    describe("Impact Assessment", function () {
        it("Should quantify financial impact of exploit chain", async function () {
            const totalAtRisk = ethers.parseEther("10.0");
            
            console.log("    === Financial Impact Assessment ===");
            console.log("    Total funds at risk:", ethers.formatEther(totalAtRisk), "ETH");
            console.log("    Attack cost: Gas fees only (~$50-100)");
            console.log("    Success rate: 100% if token ownership gained");
            console.log("    Time to execute: < 5 minutes");
            console.log("    Detection difficulty: Low (on-chain visible)");
            console.log("    Recovery possibility: None (funds transferred)");
            console.log("");
            console.log("    ❌ Risk-Reward ratio: Extremely favorable for attacker");
        });
        
        it("Should assess systemic risk from coupling", async function () {
            console.log("    === Systemic Risk Assessment ===");
            console.log("    Coupling points identified:");
            console.log("      1. GovToken.owner -> ProtocolVault.governor");
            console.log("      2. System contracts share same governance");
            console.log("      3. No isolation between token and vault");
            console.log("      4. Protocol blindly trusts governance");
            console.log("");
            console.log("    Failure propagation:");
            console.log("      - Single point compromise affects all components");
            console.log("      - No circuit breakers to stop cascade");
            console.log("      - No emergency pause mechanism");
            console.log("");
            console.log("    ❌ Systemic risk level: CRITICAL");
        });
    });
});
